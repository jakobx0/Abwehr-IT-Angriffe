 >[!info] Transportschicht
 >
 >**Verbindungslos:**
 >- UDP (User Datagramm Protocol)
 >- IPX (Internetwork Packet eXchange)
 >**Verbindungsorientiert:**
 >- TCP (Transmission Control Protocol)
 >- SPX (Sequenced Packet Exchange)
 >
 >**Verbindungslos vs. Verbindungsorientiert**
 >- Verbindungsorientiert
 >	- Verbindungsorientierte Protokolle sind mit einem Telefongespräch vergleichbar. Es gibt eine Begrüßung, eine Datenübertragung und eine Verabschiedung
 >- Verbindungslos
 >	- Verbindungslose Protokolle können mit einem Brief verglichen werden. Ein Brief wird einfach losgeschickt, was danach passiert ist unklar.
 
 > [!abstract] User Datagramm Protocol - UDP
 >  ![[Pasted image 20251116114414.png]]
 >
 >Grundlagen zu UDP 
 >- Beschreibung: RFC 768
 >- Eigenschaften: Verbindungslos
 >- Daten sind Unbestätigt
 >- Arbeitet ohne jede Fehlerkorrektur
 >
 >UDP kann auch als eine Art leere Transportschicht mit Durchgriff auf IP angesehen werden.
 
 > [!info] Aufteilung der Portnummern
 > Port = Schnittstelle zu einem Dienst/Applikation realisiert durch ein entsprechendes Protokoll der höheren Schichten.
 > 
 > Es gibt maximal 2$^{16}$ - 1 Ports, die in folgende Klassen eingeteilt sind:
 > - Reserviert (Well Known):  1...255 für TCP/IP-Dienste, 256... 1023 für Unix-Anwendungen
 > - Registriert: 1024...49151 Services, die einen  Dienst serverseitig anbieten
 > - Dynamisch, vergänglich: 49152...65535 Clientseitige Ports
 > 
 > Well Known Ports:
 > ![[Pasted image 20250123121427.png]]
>
>Aufteilung Portnummern
>- Ports um zwei Verbindungen gleichzeitig abzuwickeln
>- Anhand von Portnummer -> Downloads trennen
>Beispiel:
>Ein Client startet 2 Downloads gleichzeitig. Ein weiterer einen Download. Die Clienten wählen unterschiedliche Ports. Beide verbinden sich mit Server Port 80. 
>
>![[Pasted image 20250123121727.png]]
>
>Zuordnung zu reservierten Diensten steht beispielsweise in folgenden Dateien:
>Unix:
>- `/etc/services`
>Windows:
>- `\%Systemroot%\System32\Drivers\Etc\Services`
>
>Einige der Port-Nummern sind für die beiden Transportprotokolle TCP und UDP doppelt vergeben. Die Port-Nummern adressieren Prozesse/Programme. IP-Adresse + Port-Nummer + Protokoll definiert damit exakt einen Dienst bzw. Applikation in einem bestimmten System.

>[!danger] Angriffe auf UDP
>**UDP-Flooding:**
>Nutzt die verbindungslose Implementation von UDP. Das UDP Protokoll besitzt keine Möglichkeit, den Empfang eines gesendeten Pakets zu kontrollieren. TCP ist in der Lage, auf eine verzögerte Empfangsbestätigung durch Senken der Sendehäufigkeit zu reagieren, während UDP unverändert weiter sendet. Da UDP-Pakete Vorrang vor TCP-Paketen haben, belegt der UDP-Verkehr nach einiger Zeit die gesamte Bandbreite einer Verbindung und unterbindet damit den TCP-Verkehr. Als Schutz vor UDP-Flooding können unerwünschte UDP-Pakete in der Firewall ausgefiltert werden.
>
>**Beispiel:**
>**Chargen-Angriff**
>Dazu wird der Zeichen erzeugende Dienst Chargen eines Rechners mit dem die empfangenen Daten reflektierenden Dienst Echo eines anderen Rechners verbunden. Der Angreifer sendet UDP-Pakete zum chargen-Port (19) seines Opfers und gibt als Quelle den echo-Port (7) und eine ggf. gefälschte Quelladresse an. Der so erzeugte 'UDP Packet Storm' kann bei geeigneter Wahl der IPv4- Adressen ein ganzes Netzwerk lahmlegen.
>
>**Fraggle-Angriff:**
>verwendet statt ICMP, UDP-Echo Pakete.
>Dabei wird ein Paket an eine Broadcast-Adresse geschickt, die es an jeden Rechner im betreffenden Netzwerk weiterleitet. Ein Angreifer kann eine Folge von UDP-Echo-Paketen mit der IPv4- Adresse des gewünschten Opfers als Quelle an die Broadcast-Adresse des Netzwerks des Opfers senden. Alle Rechner im betroffenen Netzwerk antworten darauf mit einem ECHO-REPLY-Paket an das Opfer, das davon überflutet wird.

### TCP
> [!abstract]
> ![[Pasted image 20250123123211.png]]
> **TCP-Seqence Number**
> Bytecounter, 32 Bit Integer, dessen Initialwert wird beim Start der TCP-Verbindung festgelegt.
>
>Zwei Sequenznummern:
> 1. Source Sequence Number
> 2. Acknowladgement sequence Number
>
> Es muss nicht nach jedem Paket ein Ack erfolgen. Ein Ack kann sich auch auf mehrere Pakete beziehen.
>
>>[!example] Beispiel: Start Source Sequence Number ist 101. 
>>- Bob sendet 3 Bytes, im Feld Source Sequence Number steht 101 
>>- Alice acknowledged mit Acknowledgement Sequence Number 104. 
>>- Bob will weitere 3 Byte senden, im Feld Source Sequence Number steht 104
>>- Alice acknowledged mit Acknowledgement Sequence Number 107.
>>
>>![[Pasted image 20251116122051.png]]
>>
>>**Berechnung der neuen Seqenznummer:**
>>
>>![[Pasted image 20241106143738.png]]
>
>TCP-Offset [[6. UDP TCP Port Scanning#TCP]]
>- Länge des TCP Headers in 32 Bit Windows
>- Fast immer 5 für 20 Byte = Standard TCP Headersize
>- Am Anfang der Session häufig größer weil MSS (Maximum Segment Size) ausgehandelt wird.
>- MSS ist standardmäßig 1460 Byte, da: 1460 Byte + 20 Byte TCP-Header + 20 Byte IP-Header 1500 Byte = MTU
>
>TCP-Flags [[6. UDP TCP Port Scanning#TCP]]
>- URG: Urgent Pointer Field soll ausgewertet werden.
>- ACK: Acknowledgement Sequence Number soll ausgewertet werden
>- PSH: Alle Signale an Anwendung schicken (für Telnet)
>- RST: Reset Connection
>- SYN: Source Sequence Number synchronisieren
>- FIN: Dieses Segment ist das letzte vom Sender, danach Teardown
>
>TCP-Window [[6. UDP TCP Port Scanning#TCP]]
>- Client und Host reservieren am Anfang einer TCP Session Speicher.
>- Dieser Speicher dient dann als Puffer für die Nachrichten.
>- Im Window Fenster teilen sich die Kommunikationspartner mit, wie viel Speicher Ihnen noch zur Verfügung steht.
>- Dies kann zur Flusskontrolle verwendet werden.
>- In der Praxis variiert der Eintrag oft stark.
>
>TCP-Checksum [[6. UDP TCP Port Scanning#TCP]]
>Die Checksumme berechnet sich aus dem "Pseudo Header":
>- Quell-IP
>- Ziel-IP
>- Reserved-Bits
>- TCP-Flags
>- Länge des TCP-Pakets inkl. Header
>
>Dieser Pseudo Header existiert nicht wirklich und wird so nie übertragen, er wird nur zur Checksummenberechnung herangezogen. Falls das Ergebnis eine ungerade Anzahl von Octets bildet wird mit Nullen gepadded bis zur Komplementierung eines 16Bit Words.
>
>TCP-Urgent Pointer [[6. UDP TCP Port Scanning#TCP]]
>
>Der Wert des Pointers ist ein positiver Offset der Sequenznummer. Dies entspricht einem Byteversatz zu einer Stelle, an der dringende Daten
>vorgefunden werden. TCP signalisiert damit, dass sich an einer bestimmten Stelle im Datenstrom wichtige Daten befinden, die sofort gelesen werden sollten (UNIX SIGURG Message an Application). Der Urgent Pointer wird nur ausgewertet wenn das Urgent Flag gesetzt ist.
>
>TCP - Options [[6. UDP TCP Port Scanning#TCP]]
>- 0 (8 Bit): Ende der Options Liste
>- 1 (8 Bit): No operation (NOP, Padding) Wird verwendet um die Optionsliste auf ein Vielfache von 32Bit zu strecken aus Performance Gründen.
>- 2,4,SS (32 Bit): Maximum segment size (nur bei [SYN])
>- 3,3,S (24 Bit): Window scale (nur bei [SYN])
>- 4,2 (16 Bit): Selective Acknowledgement erlaubt. (nur bei [SYN])
>- 5,N,BBBB,EEEE,...: (variable Länge, N ist 10, 18, 26, oder 34) Selective ACKnowledgement (SACK), auf die ersten 2 Bytes folgt eine Liste mit bis zu 4 Paketen
>- 8,10,TTTT,EEEE (80 bits): Timestamp und Echo Timestamp

#### **3 Wege Handshake**
![[Pasted image 20250203123606.png]]
![[Pasted image 20250203123647.png]]
![[Pasted image 20250203123710.png]]
![[Pasted image 20250203123724.png]]
### Angriffe gegen TCP
>[!example]
>- gut für DoS Angriffe geeignet
>- Sogar große Server mit Load Balencern, etc. lassen sich mit DDoS Angriffen auf TCP gut in die Knie zwingen 
>- aktuelle DoS Angriffe laufen zumeist gegen TCP.
>
>>[!danger] **SYN-Flooding Angriff** (DoS)
>>Senden einer großen Anzahl von SYN-Paketen. Diese werden vom Opfer mit einem SYN/ACK-Paket beantwortet und eine TCP-Verbindung wird reserviert. Der Angreifer antwortet auf die SYN/ACK-Pakete nicht, sodass der 3-Wege-Handshake nicht vollendet wird.
>>- 1) Schicke TCP-Session Startup mit SYN flag1
>>- 2) Server schickt ACK + SYN-Paket
>>- 3) => Angreifer Stoppt den 3 Wege Handshake und sendet kein ACK-Paket
>>
>>Die beim Opfer erzeugten halboffenen TCP-Verbindungen belegen Ressourcen, sodass nach einiger Zeit keine weiteren Verbindungen mehr angenommen werden können. Der reserviert Speicher für das Window kann vom Angreifer über TCP Options beeinflusst werden.
>
>>[!question] **Abwehr mittels SYN Cookies:**
>>Das Transmission Control Protocol (TCP) macht keine Vorgaben zum initialen Wert der Sequenznummer der SYN/ACK-Pakete. Also kann der Server sie nutzen, um Informationen zu kodieren, die er sonst in einer Tabelle halboffener TCP-Verbindungen speichern müsste. Da es somit keine solche Tabelle gibt, kann sie auch nicht überlaufen, womit ein SYN-Flood-Angriff nicht zu einem DoS führen kann.
>>
>>Für die Durchführung einer erfolgreichen SYN Flood DoS Attacke bei aktivierten SYN Cookies, ist es nötig einen kompletten 3-Wege-Handshake auszuführen und über die Anzahl der Zugriffe den TCP Stack zum Überlaufen zu bringen.
>
>>[!danger] **RST Angriff (Teardown-Attacke):** 
>>Senden eines TCP-Paketes mit gesetztem RST Flag, unter Beachtung:
>>- Pakete müssen zur Verbindung passen
>>- Absender-Port und Adresse fälschen
>>- Ziel-Port und Adresse passend wählen als Schutz vor willkürlichen Resets werden die Sequenznummer der Pakete herangezogen:
>>- Sequenz-Nummer (ein 32-Bit-Wert) daher Wahrscheinlichkeit von 1 zu 232 die richtige Sequenznummer zu erraten
>>- Der TCP-Stack akzeptiert Sequenz-Nummern im Bereich der Window Size (maximale Window Size 64k)! -> daher lediglich 65.535 RST-Pakete durch Angreifer nötig
>
>>[!danger] **TCP/IP-Spoofing:**
>>Das Spoofen von IP-Adressen alleine stellt noch keinen Angriff dar, sondern ist i.d.R. nur ein Teil eines Angriffs. Es kann z.B. verwendet werden, um den Verursacher eines DoS-Angriffs zu verbergen. Kombiniert mit dem Erraten gültiger Sequenznummern und einem DoS-Angriff kann es von einem Angreifer verwendet werden, um sich in eine auf Basis der IP-Adresse authentifizierte Verbindung einzuschleichen. Statt nur Daten einzuschleusen, kann der Angreifer auch die Kontrolle über eine Verbindung übernehmen.
>
>>[!danger] **TCP-Hijacking:**
>>Angreifer Schaltet sich in eine bestehende Verbindung ein. Dazu belauscht (sniffed) er den Datenverkehr und übernimmt in einem geeigneten Moment die Kontrolle über eine ausgewählte Verbindung, indem er entsprechend manipulierte TCP-Pakete an die Kommunikationspartner sendet. Ziel eines solchen Angriffs ist z.B. die komplette Übernahme der Verbindung einschließlich Disconnect eines der Kommunikationspartner, das Einschleusen von Befehlen oder das Umgehen von Schutzmaßnahmen wie Authentifizierungen
>>
>>Vor dem Angriff Sniffen:
>>- Verbindung stören: erster Schritt des Angriffs, die Verbindung desynchronisieren. Eine Desynchronisation liegt vor, wenn die Sequenznummer eines empfangenen Pakets nicht mit einer erwarteten Sequenznummer übereinstimmt.
>>
>>Pakete einschleusen: 
>>- Nach der Desynchronisation kommt es zu einem 'ACK-Storm': Kommunikationspartner erkennen falsche Sequenznummern, verwerfen empfangenen Pakete, fordern mit ACK-Paketen an.
>>- Der Angreifer kann den ACK-Storm begrenzen, indem er selbst die falschen Pakete bestätigt (acknowledget).
>>- Der Angreifer kann als Vermittler arbeiten, indem er die Pakete 'übersetzt' (also gültige Sequenznummern einträgt) und ansonsten unverändert weiterleitet, oder aktiv in die Kommunikation eingreifen und die Nutzdaten nach seinen Wünschen manipulieren.
>>
>>Opfer aussperren:
>>- durch DoS, DDoS, bzw. Spoofing Attacke einen erneuten Verbindungsversuch des Opfers verhindern.
>>
>>**TCP-Hijacking mittels Sequenznummer Offset:**
>>Durch Senden von doppelten Paketen mit richtiger Sequence-Number an den Host können Pakete mit Offset eingefügt werden, die im TCP Stack (Window Size) des Hosts abgelegt werden:
>>
>>![[Pasted image 20251120141831.png]]
>>
>>Die im Stack abgelegten Pakete werden an Hand der Sequence Nummer im Stack positioniert und warten auf die Pakete die vermeintlich dazwischen fehlen. Wird jetzt ein FIN an den host gesendet , wird der Stack an die Applikation weitergegeben (Je nach Implementation des TCP Stacks auch bei einem RST).
>>
>>>[!question] Beispiel:
>>>Der Angreifer wartet bis zum gewünschten Zeitpunkt, z.B. nach dem erfolgreichen Telnet- Login, und startet dann den Angriff. Dazu stehen ihm mehrere Möglichkeiten zur Verfügung:
>>>- Desynchronisation durch RST/SYN-Pakete: Angreifer antwortet an Stelle des Opfers auf ein SYN/ACK-Paket mit einem RST- und einem SYN-Paket
>>>- Desynchronisation durch Infiltration: Angreifer sendet Datenpaket mit gültiger Sequenznummer an Server, der es normal verarbeitet, danach ist die Verbindung desynchronisiert, da nächstes Paket des Opers mit bereits 'verbrauchter' Sequenznummer versehen
>>>- Angriff ohne Rücksicht auf Verluste ("Take-No-Prisoners", "Simple Hijack"): entweder einschleusen ohne Tarnung oder Tarnung durch fingierte Fehlermeldung des angegriffenen Protokolls ('Session closed' o.ä.) und/oder ein FIN- oder RST-Paket an das Opfer. Auch eine Resynchronisierung der Verbindung kann den Angriff vertuschen.
>>>- Übernahme während des Verbindungsaufbaus ("EarlyDesynchronization"): Angreifer antwortet an Stelle des Opfers auf ein SYN/ACK-Paket mit einem RST- und einem SYN-Paket während des 3 Wege Handshake 
>>
>>>[!example] Session Hijacking Tools:
>>>Ws gibt eine Vielzahl an session Hijacking Tools und durchgeführte Angriffe mit gleichlautendem Namen:
>>>- Juggernaut
>>>- Hunt
>>>- TTY Watcher
>>>- IP Watcher
>>>- IP Watcher
>>>- T-Sight
>>>- Remote TCP Session Reset Utility
>>>
>>>>[!abstract] Juggernaut
>>>>- Juggernaut ist ein Netzwerk-Sniffer, mit dem TCP-Sitzungen gehijackt werden können.
>>>>- es läuft auf Linux-Betriebssystemen
>>>>- es kann so eingestellt werden, dass der gesamte Netzwerkverkehr überwacht wird, oder es kann ein Schlüsselwort (z. B. „Password“) angegeben werden, nach dem gesucht werden soll
>>>>- es kann Informationen zu laufenden Netzwerksitzungen bereitzustellen
>>>>- ein Angreifer kann alle Sitzungen sehen und eine Sitzung hijacken
>>>>
>>>>![[Pasted image 20251123141932.png]]
>>>
>>>>[!abstract] Hunt
>>>>Hunt ist ein Programm, mit dem aktive Sitzungen in einem Netzwerk abgehört, abgefangen und gehijackt werden können.
>>>>Hunt bietet:
>>>>- Verbindungsverwaltung
>>>>- ARP-Spoofing
>>>>- Vewrbindung resetten
>>>>- Verbindungen sniffen
>>>>- MAC-Adresserkennung
>>>>- Abhöhren von TCP-Verkehr
>
>>[!success] Werkzeuge zur Paketerstellung:
>>**HPing3:**
>>- Bei hping3 erfolgt die Konfiguration der Pakete über Kommandozeilenparameter beim Aufruf.
>>- Die möglichen Optionen sind sehr vielfältig und erlauben es Pakete fein granular zu erstellen.
>>
>>**Beispiel für DoS Angriff mit hping:**
>>Erzeuge TCP SYN Paket mit hping3: (einfacher SYN auf Port 6666)
>>```bash
>>hping3 -c 1 -p 6666 -S 10.10.1.9
>>```
>>Problem, wenn Server auf ACK keine Antwort bekommt sendet er RST und belegt Ressourcen auf dem Client. Lösung: ACK umleiten:
>>```bash
>>hping3 -c 1 -a 10.12.250.250 -p 6666 -S 10.10.1.9
>>```
>>
>>**Scapy:**
>>„Scapy ist ein leistungsstarkes interaktives Paketmanipulations- programm. Es ist in der Lage, Pakete einer großen Anzahl von Protokollen zu fälschen oder zu dekodieren, sie zu senden, sie zu erfassen, Requests und Replies abzugleichen und vieles mehr. Die meisten klassischen Aufgaben wie Scannen, Tracerouting, Probing, Unit Tests, Angriffe oder Netzwerkerkennung können problemlos ausgeführt werden (Es kann HPing, 85% von NMAP, arpspoof, arp-SK, arping, TCPDump, tethereal, p0F usw. ersetzen.)“
>>
>>**Pakete durch Scapy erzeugen:**
>>
>>![[Pasted image 20251123145107.png]]
>>
>>Und die dazugehörige Befehlsreferenz:
>>
>> ![[Pasted image 20251123145205.png]]
>>
>>Das von Scapy erzeugte Paket in Wireshark dargestellt:
>>
>>![[Pasted image 20251123145322.png]]
>>
>>Es gibt auch eine Scapy Funktion namens aepcachepoison(), die verwendet werden kann, um eine ARP-Response mit der Angreifer MAC-Adresse und Opfer IP an das Gatway-Zielsystem zu senden:
>>
>>![[Pasted image 20251123150553.png]]
>>
>>Und die dazugehörige Befehlsreferenz:
>>
>>![[Pasted image 20251123150630.png]]
>>
>>>[!question] Absicherung und Abwehr von Hijacking Angriffen:
>>>- Benutzu
>
>>[!bug] **Port-Scanning**
>>Schicke eine Anfrage(SYN) an alle Ports des Zielsystems
>>- Antwort: Port ist aktiv (offen/open)
>>- keine Antwort: Port ist inaktiv (geschlossen/closed, gefiltert oder geblockt)
>>
>>Selbst für alle 65635 Ports über das Internet in 7  Minuten möglich.
>>![[Pasted image 20250203124804.png]]
>>
>>zu scannender Host ist:
>>- im selben Subnetz
>>- im fremden Subnetz
>>- im fremden Subnetz hinter einem filtenden Router
>>- im fremden Subnetz hinter einem Address Translator
>>- im fremden Subnetz hinter einem Address Translator(NAT)
>>- im fremden Subnetz einer Firewall
>>
>>Beispiele mit nmap:
>>![[Pasted image 20251120113837.png]]
>>
>>![[Pasted image 20251120114117.png]]
>>
>>![[Pasted image 20251120123509.png]]
>
>**OS-Fingerprinting**
>Die Erkennung entfernter Betriebssysteme durch OS-Fingerprinting
>geschieht für gewöhnlich durch eine Analyse des TCP/IP-Stacks.
>Dabei werden zunächst verschiedene, speziell vorbereitete
>Nachrichten an das Zielsystem gesendet, die die Options Felder im
>TCP/IP ausnutzen. Anhand des unterschiedlichen Antwort-Verhaltens verschiedener TCP/IP-Implementierungen in verschiedenen Betriebssystemen können Rückschlüsse auf das verwendete Betriebssystem gezogen werden. Durch eine Kombination verschiedener Tests lässt sich die Treffer Wahrscheinlichkeit verbessern.
>
>**Ziele Service-Fingerprinting:**
>- Anwendungsprotokoll ermitteln
>- Server-Software herausfinden
>- Release identifizieren
>
>Die Techniken dazu sind das Application-Mapping und Banner-Grapping
>
>![[Pasted image 20251120124157.png]]
>
>amap identifiziert Applikationen hinter den Ports:
>
>```bash
>nmap -sS -oM ./results.nmap -p 1-65535 HOST
>amap -i ./results.nmap -o ./results.amap -m 
>```
>
>Fuzzy OS Fingerprinting mit Xprobe2:
>
>![[Pasted image 20251120124825.png]]
>
>OS Fingerprinting Abwehren:
>- Abwehr von Fingerprinting durch Verändern kleiner Parameter wie:
>	- TTL
>	- ICMP Options
>	- ...
>
>Port Scanning Abwehren mittels Port Knocking
>
>Aktives Fingerprining erfordert es, dass erstmal irgendeineKommunikation mit dem zu testenden Port stattfindet. Port Knocking ist eine Abwehrtechnik die Aktives Fingerprinten verhindert:
>- Bevor ein Port geöffnet wird muss an einer Reihe von anderen Ports in der richtigen Reihenfolge angeklopft werden.
>- Macht das System nicht sicherer, sondern erschwert nur das Scannen.
>- Für große öffentliche Server eher nicht geeignet.
>
>Port Scanning Abwehren mittels Port Knocking
>
>Im folgenden Beispiel eine Session mit Port Knocking zur Anmeldung an einen SSH Server unter Linux:
>
>![[Pasted image 20251120131017.png]]
>
>Zusammenfassung:
>
>Neben dem TCP Transmission Control Protokoll gibt es im Bereich der Transport Protokolle noch das UDP User Datagram Protokoll, welche beide für die Übertragung von Daten in IP basierten Netzwerken zum Einsatz kommen. Für die Datenübertragung werden Ports verwendet, welche die Schnittstellen zu den einzelnen höherwertigen Protokollen und letztlich Anwendungen darstellen. Transportprotokolle sind trotz verschiedener Sicherungs-mechanismen, wie für TCP der 3-Wege-Handshake, anfällig für Manipulationen. Der überwiegende Teil von Angriffen wird dem Bereich der DoS bzw. DDoS Attacken zugerechnet. Aber auch MitM Attacken sind bei einfachen Anwendungen möglich. TCP und UDP werden zudem genutzt für das Ausforschen von Opfern durch Port Scanning und Fingerprinting.

