> [!question] Zielstellung
> In diesem Praktikum lernen Sie die grundlegenden Techniken kennen, mit denen ein Exploit durch einen Pufferüberlauf (engl. Buffer Overflow) aufgebaut wird. Als anschauliches Beispiel dient ein bewusst vereinfachter FTP-Server, an dem Sie typische Angriffs- und Analysewege nachvollziehen können. Dabei wenden Sie grundlegende Programmierkenntnisse an und vertiefen Ihr Verständnis für typische Schwachstellen, wie sie auch in aktuellen Systemen auftreten können.

## Grundlagen
> [!abscract]
>  Die Entwicklung von Exploits ist eine anspruchsvolle Aufgabe. Der schwierigste Teil besteht meist darin, geeignete Sicherheitslücken zu identifizieren, die sich tatsächlich ausnutzen lassen. In diesem Praktikum wurde die Schwachstelle bereits für Sie lokalisiert, sodass Sie sich vollständig auf den nächsten Schritt konzentrieren können. Dieser umfasst das gezielte Ausnutzen des Fehlers und die Platzierung eines passenden Payloads. Der Fokus liegt auf einem klassischen Pufferüberlauf (engl. Buffer Overflow) innerhalb des Stacks eines vereinfachten FTP-Servers. Ein Pufferüberlauf entsteht durch einen Programmierfehler, bei dem die Länge einer Eingabe nicht korrekt geprüft oder verarbeitet wird. Werden mehr Daten in einen vorgesehenen Speicherbereich geschrieben, als Kapazität vorhanden ist, überschreibt die Eingabe benachbarte Speicherzellen. Oft stürzt das Programm dabei ab und erzeugt einen Segmentation Fault. Mit präziser Manipulation der überschriebenen Speicherregionen lässt sich der Programmablauf jedoch aktiv umlenken, was den Kern vieler Exploit-Techniken bildet. Historisch zählen Pufferüberläufe zu den bedeutendsten Schwachstellen der IT-Sicherheitsgeschichte. Viele Angriffe der frühen 2000er Jahre nutzten genau diese Art von Programmfehlern, um Systeme unter ihre Kontrolle zu bringen oder Schadcode einzuschleusen. Auch wenn moderne Betriebssysteme heute über deutlich robustere Sicherheitsmechanismen verfügen, sind die klassischen Angriffstechniken weiterhin relevant, da sie das Fundament vieler aktueller Methoden bilden. Zu diesen Schutzmechanismen gehören unter anderem ASLR1 zur zufälligen Anordnung des Adressraums, DEP bzw. NX2 zur Unterbindung der Ausführung von Code im Stack und Stack Canaries3, die Manipulationen an wichtigen Stackstrukturen erkennen sollen. Für das Grundverständnis der Abläufe ist es jedoch hilfreich, zunächst ein bewusst einfach gehaltenes System ohne diese Schutzschichten zu betrachten. Beim Start eines Programms wird dessen Code in den Hauptspeicher geladen. Die Verwaltung von Variablen, Speicherobjekten und Funktionsaufrufen erfolgt hauptsächlich über die beiden Speicherbereiche Heap (dynamischer Speicher) und Stack (statischer Speicher). Der Stack lässt sich vereinfacht als ein Bereich vorstellen, der in Blöcken fester Größe organisiert ist und Funktionsaufrufe samt lokaler Variablen verwaltet. Heap und Stack teilen sich denselben Adressraum des Prozesses und wachsen dabei typischerweise aufeinander zu. Der Heap expandiert ausgehend von niedrigen Adressen in Richtung höherer Adressbereiche. Der Stack liegt am oberen Ende des Speicherbereichs und wächst beim Ablegen neuer Daten in Richtung niedrigerer Adressen. Abbildung 1 zeigt den schematischen Aufbau eines typischen Stacks und verdeutlicht seine Schichtung.
>  
![[Pasted image 20260104144016.png]] 
>
   Die schematische Darstellung des Stacks zeigt die grundlegende Schichtung und Organisation der Speicherbereiche für Funktionsaufrufe. Insbesondere die Rücksprungadresse jedes Stack Frames spielt eine entscheidende Rolle für den späteren Programmablauf. Ein Überlauf in einem lokalen Puffer kann daher nicht nur benachbarte Daten überschreiben, sondern gezielt die Rücksprungadresse verändern und so den Kontrollfluss umlenken. Wenn Sie die Lage der lokalen Variablen, der Parameter und der gesicherten Register betrachten, wird klar, welche Speicherbereiche besonders sensibel sind – alle die nach dem lokalen Puffer liegen. Dieses Zusammenspiel aus Speicheranordnung und Registerverwaltung bildet die Grundlage für die folgenden Angriffstechniken. In Abbildung 2 ist dargestellt, wie ein gezielt präparierter Buffer Overflow die Rücksprungadresse verändert und den Prozessor auf den platzierten Payload springen lässt.
>
>![[Pasted image 20260104144207.png]]
>
>Wird eine Funktion (bzw. Subroutine) von einem Prozess aufgerufen, erzeugt das System auf dem Stack einen neuen Stack Frame. Dieser Frame enthält die lokalen Variablen der Funktion, ihre Aufrufparameter und außerdem gesicherte Werte zentraler CPU-Register. Da diese Register während der Funktionsausführung verändert werden, müssen ihre ursprünglichen Werte zu Beginn der Funktion gesichert werden, damit sie nach dem Funktionsende wiederhergestellt werden können. Für das hier vorgestellte Verfahren ist vor allem die Rücksprungadresse entscheidend. Sie wird nach Abschluss der Funktion in das Befehlszählregister EIP geladen und legt fest, an welcher Stelle das Programm weiter ausgeführt wird. Die relevanten CPU-Register und ihre Bedeutung sind in Tabelle 1 zusammengefasst.
>
>![[Pasted image 20260104144315.png]]
>
>Auch wenn der Stack als Speicherbereich in Richtung niedrigerer Adressen wächst, sind die einzelnen Werte innerhalb des Stack Frames logisch vorwärts organisiert. Der lokale Puffer in Abbildung 1 beginnt zum Beispiel beim Offset [EBP - 16 Bytes] und reicht bis [EBP - 4 Bytes]. Diese Anordnung spielt eine zentrale Rolle beim Verständnis von Pufferüberläufen, da sich daran ablesen lässt, welche Speicherbereiche im Fall eines Überlaufs zuerst überschrieben werden. Ihr Ziel besteht darin, die Datenstrukturen auf dem Stack so zu beeinflussen, dass Sie über die Grenzen eines lokalen Puffers hinweg die zuvor gesicherten Registerwerte überschreiben können. Sobald die aktuelle Funktion beendet ist, werden diese manipulierten Werte zurück in die CPU-Register geladen und verändern damit den weiteren Programmablauf. Ein geschickt aufgebauter Pufferüberlauf kann sogar so weit reichen, dass auch tiefer liegende Stack Frames überschrieben werden. Auf diese Weise lässt sich gezielt Schadcode (Payload) direkt auf dem Stack ablegen, der später ausgeführt werden soll. Das konkrete Ziel besteht darin, die Rücksprungadresse für den EIP so zu manipulieren, dass der Kontrollfluss zu einem zuvor platzierten Codeabschnitt springt. Üblicherweise wird dazu eine Sprunganweisung genutzt, die den ESP ansteuert, damit der Prozessor den auf dem Stack liegenden Payload ausführt. Das grundlegende Vorgehen soll sich entsprechend Abbildung 2 annähern.

#### Vorbereitung der Testumgebung
>[!info]
>Für die vorliegende Aufgabenstellung benötigen Sie zwei virtuelle Maschienen: die ForDeb-VM als Angreifersystem und die Windows-VM als Testplattform5. Die Windows-VM repräsentiert dabei gleichzeitig Ihre spätere „Opfer-Konfiguration“ – ein Windows XP SP2 mit laufendem, anfälligem FTP-Server.
>
>Um die internen Abläufe des FTP-Servers nachvollziehen zu können, benötigen Sie ein Debug-Programm (Debugger). Damit analysieren Sie den Programmcode, beobachten das Verhalten des Prozesses und sammeln gezielt Informationen für den anschließenden Exploit. In diesem Praktikum verwenden Sie den Debugger OllyDbg, der sich besonders für klassische Windows-Analysen eignet.


