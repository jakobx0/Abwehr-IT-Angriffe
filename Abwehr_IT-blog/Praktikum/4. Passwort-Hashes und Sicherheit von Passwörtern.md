>[!question] Zielstellung:
>Das Ziel des Praktikums ist es, praxisnahe Kenntnisse zur Sicherheit von Passwörtern zu vermitteln. Als Praxisbeispiele dienen Kennwortdaten aktueller Betriebssysteme, wobei der Schwerpunkt auf der Analyse von Passwortstärke und typischen Angriffsvektoren liegt. Die zugrunde liegenden Konzepte lassen sich auf nahezu alle Formen von Passwortdaten übertragen.

>[!abstract] Grundlagen: Hash-Werte und Hash-Kodierung
>Geht es um die Speicherung von Passwörtern, so werden diese – bei sicher konzipierten Systemen nicht im Klartext abgelegt. Stattdessen wird das Passwort durch ein Hashverfahren in einen Wert fester Länge umgewandelt. Bei einer Authentifizierung wird die aktuelle Passworteingabe mit demselben Verfahren gehasht, und die resultierenden Werte werden miteinander verglichen. Auf diese Weise lässt sich im Fall von Systemfehlern oder Datenlecks zumindest die Preisgabe der ursprünglichen Passwörter verhindern.
>
>Dieser Festwert wird als Hash-Wert (kurz: Hash) bezeichnet und durch einen sogenannten Hash Algorithmus erzeugt. Ein solcher Algorithmus bildet Eingaben beliebiger Länge auf eine Ausgabemenge fester Länge ab. Für den Einsatz in sicherheitsrelevanten Kontexten ist entscheidend, dass diese Einwegtransformation möglichst kollisionsresistent ist – also dass verschiedene Eingaben nur äußerst selten denselben Hash erzeugen und dass die Berechnung eine konsistente und ausreichend lange Laufzeit aufweist, um Angriffe zu erschweren.
>
>![[Pasted image 20251031174036.png]]
>
>**Base64-Kodierung:**
>Neben der Darstellung eines Hash-Werts in hexadezimaler Form ist es ebenso gängig, diesen in einer Base64-Kodierung oder in verwandten Varianten (z. B. Radix-64) darzustellen. **Base64 nutzt hierzu 64 Zeichen** (A-Z, a-z, 0-9, +, /) und kodiert jeweils **6 Bit pro Zeichen**, also 3 Byte Eingangsdaten zu 4 Zeichen Ausgangsdaten. Reicht der letzte Datenblock nicht aus, wird dieser mit dem Zeichen „=“ aufgefüllt. So kann der hexadezimale MD5-Hash `5f4dcc3b5aa765d61d8327deb882cf99` auch im Base64-Format als `X03MO1qnZdYdgyfeuILPmQ==` dargestellt werden.
>
>**Präffix/Suffix-Kennungen:**
>Werden in einem System verschiedene Hash-Algorithmen eingesetzt, müssen diese eindeutig identifizierbar sein. Dazu existieren Präfix- oder Suffix-Kennungen, die den jeweiligen Algorithmus und teilweise auch spezifische Parameter wie Rundenanzahl oder Salt Länge kodieren. Weit verbreitet ist hierfür das Modular Crypt Format (MCF), das eine einheitliche Kennzeichnung von Passwort-Hashes ermöglicht. Darauf aufbauend wurde 2016 das stärker standardisierte PHC-String-Format (Password Hashing Competition) eingeführt, das modernere Verfahren und Parameterstrukturen unterstützt. In sind beispielhaft zwei kodierte Hash-Werte in diesen Formaten dargestellt.
>
>![[Pasted image 20251031174917.png]]
>
>**Salt:**
>In den meisten Fällen wird für Passwortdaten eine zusätzliche Zufallskomponente in das vom Nutzer gewählte Passwort integriert (z. B. einfach angehängt oder vorangestellt). Diese Zufallssequenz wird Salt1 genannt. Der Salt wird für jeden Passworteintrag neu erzeugt und bei der Passwortprüfung erneut benötigt. Daher wird er im formatierten Hash zusammen mit weiteren Metadaten gespeichert (vgl. Abbildung 1). Diese Vorgehensweise bietet nicht nur Vorteile im Hinblick auf Passwortsicherheit, sondern erschwert auch verschiedene Angriffsarten erheblich oder macht sie ganz unwirksam.
>
>**Pepper:**
>Für Anwendungen mit erhöhtem Schutzbedarf kann zusätzlich ein Pepper – auch Secret Salt oder Secret Key genannt – eingesetzt werden. Pepper wird ebenfalls vor der Hash-Berechnung mit dem Passwort kombiniert, jedoch nicht gemeinsam mit dem Hash-Wert gespeichert. Stattdessen wird dieser geheime Schlüssel in einer separaten, besonders geschützten Persistenzschicht des Servers abgelegt. So bleiben selbst bei einem Datenbankleck keine direkt nutzbaren Informationen über die Passwortableitung zurück.
>
>Diese Erweiterungen und Anreicherungen der Passwortdaten werden vor allem bei kryptografischen Hashfunktionen verwendet, um deren Sicherheit zu erhöhen. Dadurch führen selbst identische Passwörter zu unterschiedlichen Hash-Werten, wodurch Wiederholungen und Muster vermieden werden. Neben den in diesem Praktikum relevanten kryptografischen Hashverfahren existieren zahlreiche weitere Anwendungsgebiete für Hashes, die teils andere Anforderungen an die Transformation stellen. Die in Abbildung 1 dargestellten Algorithmen gehören bereits zu einer speziellen Untergruppe, den sogenannten Schlüsselableitungsfunktionen (Key Derivation Functions, KDF). Tabelle 2 zeigt beispielhaft verschiedene Einsatzfelder solcher Funktionen und ihre jeweiligen Anforderungen.
>
>![[Pasted image 20251031175817.png]]

>[!info] Grundlagen: Passwortangriffe
>Der Angriff auf ein Passwort folgt grundsätzlich immer demselben Schema: Ein Eingangswort wird mit der erwarteten Hash-Transformation verarbeitet und der resultierende Wert mit dem gespeicherten Passwort-Hash verglichen. Stimmen beide Werte überein, gilt das Eingangswort als gültiges Passwort. Je nach Hash-Algorithmus können dabei theoretisch mehrere Eingaben denselben Hash erzeugen (Stichwort: Kollisionen).
>
>Ist ein Passwort ohne zusätzlichen Salt gespeichert, ergibt sich daraus ein sehr einfaches Angriffsszenario. Man nimmt ein Wörterbuch oder eine Passwortliste, berechnet für alle Einträge den entsprechen den Hash und speichert diese Werte sortiert in einer sogenannten Hash-Tabelle bzw. Rainbow-Table. Anschließend wird geprüft, ob der Ziel-Hash in der Tabelle vorkommt – ist das der Fall, kennt man das zugehörige Passwort. Solche Tabellen lassen sich in großem Umfang vorbereiten und mehrfach wiederverwenden.
>
>Wird ein Passwort hingegen mit einem individuellen Salt gespeichert, ist dieses Vorgehen nicht mehr praktikabel. Als Alternative kann das Wörterbuch bzw. die Passwortliste für jeden einzelnen Salt- Wert neu verarbeitet werden, um einen Wörterbuchangriff gezielt auf ein bestimmtes Passwort auszuführen. Da jedes Passwort seinen eigenen Salt besitzt, ist dieses Vorgehen deutlich aufwändiger und langsamer. Existiert zusätzlich ein geheimer Pepper (Secret Salt), der dem Angreifer nicht bekannt ist, scheitert auch dieser Ansatz.
> 
>Der Erfolg eines Passwortangriffs hängt daher maßgeblich von der Qualität des verwendeten Wörter- buchs oder der Passwortliste ab. Mittels gezieltem Profiling – also der Sammlung von Informationen über Personen, Organisationen oder Gruppen – können spezifische Passwortlisten erstellt werden. Solche Listen werden häufig durch Rekombination, Substitution und Transformation erweitert, etwa durch Varianten in Leet-Speak oder typische Schreibmuster bestimmter Nutzergruppen
>
>**John the Ripper:**
>Das Programm John the Ripper dient in diesem Zusammenhang als Beispiel für ein Passwort-Cracking-Tool und dessen Arbeitsweise. In der Standardkonfiguration arbeitet das Tool in drei Phasen:
>- Phase 1 – Single Crack and Mangling: Das Programm versucht zunächst, Passwörter aus vorhandenen Zusatzinformationen oder bekannten Mustern zu erraten (sehr schnell).
>
>- Phase 2 – Wörterbuchangriff: Es werden alle Einträge aus einer Passwortliste getestet. Dauer und Aufwand hängen von der Größe des Wörterbuchs und der verwendeten Hash-Funktion ab.
>
>- Phase 3 – Bruteforce: Schließlich werden alle möglichen Zeichenkombinationen systematisch durchprobiert, bis ein Treffer erzielt wird. Dieser Prozess kann je nach Passwortkomplexität astronomisch lange dauern.
>
>John the Ripper erwartet die Eingabedatei in einem der folgenden Formate (ein Eintrag pro Zeile):
>`Hash`
>`Nutzername:Hash`
>`Nutzername:Hash:Zusatzinformationen`
>(je mehr informationen, desto besser - siehe Phase 1.)
>
>**hashcat:**
>John the Ripper nutzt standardmäßig die Rechenleistung der CPU, kann aber – je nach Version und Konfiguration – auch GPU-Ressourcen einbeziehen. Für die in den bereitgestellten virtuellen Maschinen durchzuführenden Experimente ist das Tool daher sehr gut geeignet. Für großflächigere Passwortangriffe oder Wiederherstellungsprojekte empfiehlt sich hingegen das Programm hashcat, das für GPU-Architekturen optimiert ist und deutlich besser skaliert. Beide Tools haben ihre jeweiligen Stärken: John the Ripper ist flexibel, skriptfreundlich und ideal für forensische Einzelanalysen, während hashcat durch massive Parallelisierung eine hohe Rechenleistung bei umfangreichen Hash-Mengen ermöglicht.

>[!example] Grundlagen aus  der Microsoft-Welt (Windows-Anmeldepasswörter)
>In der Windows-Welt werden lokale Passwortdaten für Benutzeranmeldungen im SAM-Hive (Security Account Manager) der Registrierungsdatenbank (Registry) gespeichert. Diese Hash-Werte sind zusätzlich durch einen Systemschlüssel geschützt, der im SYSTEM-Hive abgelegt ist. Passwortdaten können dabei redundant vorhanden sein oder nur einmalig vorkommen. Seit Windows 8 hat sich die Speicherung insbesondere für Microsoft-Konten leicht verändert, der grundlegende Ablauf bleibt jedoch weitgehend identisch. Für das Auslesen von Domänenanmeldedaten wäre darüber hinaus der SECURITY-Hive relevant, was im Rahmen dieses Praktikums jedoch nicht betrachtet wird.
>
>In Windows-Systemen existieren zwei primäre Hash-Algorithmen, die seit vielen Jahren für lokale Benutzerkonten verwendet werden:
>- Der ältere LAN-Manager-Hash (LM-Hash) war zwischen den 1980er-Jahren und etwa 2008 weit verbreitet. Aufgrund gravierender konzeptioneller Schwächen – insbesondere der Aufteilung in zwei 7-Zeichen-Blöcke und der Nutzung von DES – gilt dieser Algorithmus heute als vollständig unsicher. Auf aktueller Hardware lassen sich LM-Hashes oft in Minuten oder Stunden durch reine Bruteforce-Angriffe rekonstruieren.
>- Der modernere NT-Hash (auch häufig NTLM-Hash genannt) wird durch den Algorithmus NT LAN Manager (NTLM) erzeugt. Er behebt einige Schwächen des LM-Vorgängers, weist aber weiterhin konzeptionelle Einschränkungen auf, etwa fehlendes Salting und die Verwendung von MD4 als Basis-Hashfunktion.
>
>Bei der Speicherung von Benutzerpasswörtern wird standardmäßig der NT-Hash verwendet. Aus Gründen der Abwärtskompatibilität kann in älteren Systemen jedoch auch eine doppelte Speicherung von LM- und NT-Hash vorkommen. Aktuelle Windows-Versionen (ab Windows Vista bzw. Windows Server 2008) deaktivieren die LM-Hash-Erzeugung standardmäßig.
>
>1.1 Vorbereitung: In diesem Praktikum lernen Sie verschiedene Passwortdaten kennen, analysieren diese und versuchen, sie zu „entschlüsseln“ bzw. zu brechen. Sie müssen sich Passwörter nicht notieren oder merken.
>
>- 1.1.1 Entpacken Sie die bereitgestellte Archivdatei passwords und binden Sie das entpackte Verzeichnis als gemeinsamen Ordner passwords in die ForDeb-VM ein. Achten Sie darauf, die Option „Automatisch einbinden“ zu aktivieren, damit das Verzeichnis beim Start der virtuellen Maschine automatisch an einem Standardpfad eingehängt wird.
>
>- 1.1.2 Starten Sie die ForDeb-VM, öffnen Sie den Dateimanager und navigieren Sie zum eingebundenen Verzeichnis sf_passwords3.
>
>1.2 Öffnen Sie zuerst die Datei `/media/sf_passwords/data/windows/plain` mit einem Texteditor. In dieser Datei sehen Sie vorformatierte Nutzerdaten im smbpasswd-ähnlichen Format, das an das Unix-passwd-Format angelehnt ist. Jede Zeile enthält die Informationen zu einem Benut- zeraccount. Die einzelnen Felder sind durch Doppelpunkte getrennt und entsprechen in der Regel einer festen Feldreihenfolge:
>
>![[Pasted image 20251031184515.png]]
>
>**ophcrack**
>1.3 Versuchen Sie, die Hashes mit Hilfe des Rainbow-Table-Tools ophcrack Passwörtern zuzuordnen.
>- 1.3.1 Starten Sie die grafische Oberfläche mittels ophcrack oder über das Startmenü.
>- 1.3.2 Laden Sie über das Menü Load das PWDUMP file des Windows-Systems: `/media/sf_passwords/data/windows/plain`
>- 1.3.3 Das Tool verwendet vorberechnete Rainbow-Tables zum „Brechen“ von Passwörtern. Öffnen Sie den Menüeintrag Tables, wählen Sie die im gemeinsamen Ordner bereitgestellten Tabellen XP free small, klicken Sie auf Install, navigieren Sie zum Verzeichnis `/media/sf_passwords/tools/tables_xp_free_small` und bestätigen Sie mit OK.
>- 1.3.4 Starten Sie den Entschlüsselungsprozess über das Menü Crack und beobachten Sie die Arbeitsweise des Programms. Sie können das Cracken jederzeit mit Stop pausieren und später fortsetzen. Achten Sie darauf, welche Passwörter frühzeitig gefunden werden und welche erst später entdeckt werden.
>- 1.3.5 Können Sie erklären, warum einige Passwörter nicht gefunden werden? Betrachten Sie besonders die Accounts Ali und Administrator.
>- 1.3.6 Bislang konnten Sie nicht alle Passwörter erlangen. Wie Sie gesehen haben, nutzt ophcrack neben Rainbow-Tables auch eine begrenzte Bruteforce-Phase. Schließen Sie ophcrack und nutzen Sie ein weiteres Tools, um die noch fehlenden Hashes gezielter zu bearbeiten
>
>![[Pasted image 20251101180952.png]]
>
>**John the Ripper**
>1.4 Öffnen Sie ein Terminal und betreten Sie das Arbeitsverzeichnis für die Windows-Daten: `cd /media/sf_passwords/data/windows`
>1.5 Lassen Sie die verbleibenden Hashes mit John the Ripper (JtR, kurz: john) bearbeiten. Da in den Nutzerdaten keine relevanten LM-Hashes mehr vorhanden sind und John the Ripper jeweils nur einen Hash-Typ pro Datei verarbeitet, wählen Sie explizit die NTLM/NT-Hashes aus: `john plain --format=NT` Die Laufzeit hängt stark von der Passwortkomplexität und der gewählten Angriffsstrategie ab. Die Verarbeitung kann einige Zeit in Anspruch nehmen (ca. 15 min). Minimieren Sie das Terminal und fahren Sie mit der Bearbeitung von Aufgabe 1.6 fort. Hinweis: Ein gefundenes Passwort wird in der Ausgabe von john angezeigt als: Passwort (Benutzername) Dabei sind normale Nutzerangaben orange/braun und Administratoren rot hervorgehoben.
>
>![[Pasted image 20251101184245.png]]
>
>1.6 Für den Fall, dass Ihnen nicht die bereits extrahierten Passwortdaten, sondern nur die Registry Hive-Dateien eines Windows-Systems vorliegen, können Sie diese beispielsweise mit dem Tool samdump2 aufbereiten.
>- 1.6.1 Extrahieren Sie die Nutzerdaten aus den bereitgestellten Hive-Dateien SYSTEM und SAM: samdump2 SYSTEM SAM (Vorausgesetzt Sie sind im richtigen Verzeichnis)
>- 1.6.2 Verwenden Sie zum Ermitteln von Klartextpasswörtern die Rainbow-Tables des freien Onlinetools Crackstation(https://crackstation.net/) oder alternative Dienste. Crackstation erwartet pro Zeile genau einen Hash-Wert beliebigen Typs. Daher müssen Sie aus dem von samdump2 generierten Format die LM- und NT-Hash-Felder extrahieren und in einer Datei mit einem Hash pro Zeile ablegen.
>
>![[Pasted image 20251101182621.png]]
>
>(Manche Werte sind Platzhalter oder repräsentieren leere Passwörter. Diese Hashes sollte man vor dem Upload ausschließen, wenn man nur sinnvolle Kandidaten testen möchte:
>	- aad3b435b51404eeaad3b435b51404ee steht oft für einen deaktivierten oder nicht vorhandenen LM-Hash.
>	- 31d6cfe0d16ae931b73c59d7e0c089c0 ist der MD4-Hash einer leeren Zeichenkette und kann auf ein leeres NT-Passwort hindeuten).
>Beachten Sie, dass Sie dadurch die direkte Zuordnung zwischen Hash und Nutzer verlieren und diese Zuordnung nach der Rückgabe der Passwörter manuell wiederherstellen müssen.
>
>![[Pasted image 20251101182709.png]]

>[!example] 2 Angriffe auf Linuxpasswörter
>In den meisten Linux-Distributionen werden die Anmeldedaten seit jeher in zwei getrennten Dateien verwaltet. Zum einen ist dies die Datei /etc/passwd, welche allgemeine Nutzerdaten ohne Passwörter für jeden sichtbar aufbewahrt, sowie die Datei /etc/shadow (im Folgenden auch Shadow-Datei), welche die Passwort-Hashes beinhaltet und nur von privilegierten Nutzern eingesehen werden darf.
>- 2.1 Wechseln Sie in das vorbereitete Linux-Verzeichnis und betrachten Sie die beiden Dateien passwd und shadow in einem Texteditor oder per Ausgabe: 
>	- `cd /media/sf_passwords/data/linux`
>	- `cat passwd`
>	- `cat shadow`
>Jede Zeile repräsentiert einen Nutzeraccount des Systems. Neben echten Benutzerkonten finden Sie zahlreiche System- und Verwaltungsnutzer. Das Format der beiden Dateien ist ähnlich aufgebaut wie in Aufgabe 1.2, unterscheidet sich jedoch in mehreren wichtigen Punkten:
>
>![[Pasted image 20251101190754.png]]
>
>Aus Sicherheitsgründen wird das Passwortfeld in der /etc/passwd-Datei durch ein „x“ ersetzt. Das bedeutet, dass der eigentliche Passwort-Hash in der /etc/shadow-Datei verwahrt wird. Dieses Trennprinzip ist seit den frühen 1990er-Jahren Standard und verhindert, dass Passwort-Hashes für alle Systemnutzer sichtbar sind.
>
>- 2.2 Die shadow-Datei mit den Hashes reicht grundsätzlich aus. Die /etc/passwd-Datei enthält je- doch oft nützliche Zusatzinformationen, die John in Phase 1 (Single Crack and Mangling) verwerten kann. Führen Sie die beiden Dateien deshalb für größte Erfolgsaussichten zusammen:
>`unshadow passwd shadow > unshadowed`
>- 2.3 Starten Sie auf Basis der zusammengeführten Datei einen Passwortangriff mit John the Ripper und lassen Sie das Programm automatisch die verwendeten Hash-Typen erkennen:
>	- `john unshadowed` 
>	Hinweis: Falls john aus Aufgabe 1.4 noch läuft, kann die Session-Datei gesperrt sein und der neue Aufruf meldet „Crash recovery file is locked“. Starten Sie in diesem Fall eine explizit benannte, unabhängige Session: john unshadowed --session=linux (Nur nötig, falls john noch zeitgleich läuft)
>- 2.4 Das Brechen der Passwörter gelingt bereits in der ersten Phase von John the Ripper. Beim Vergleich von Benutzernamen und gefundenen Klartexten fällt möglicherweise eine Auffälligkeit auf. Hätten Sie alle Passwörter ebenfalls erraten können, und woher hat das Programm diese Informationen genommen?

