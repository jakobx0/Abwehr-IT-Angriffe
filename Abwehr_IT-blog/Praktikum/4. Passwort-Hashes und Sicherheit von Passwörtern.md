>[!question] Zielstellung:
>Das Ziel des Praktikums ist es, praxisnahe Kenntnisse zur Sicherheit von Passwörtern zu vermitteln. Als Praxisbeispiele dienen Kennwortdaten aktueller Betriebssysteme, wobei der Schwerpunkt auf der Analyse von Passwortstärke und typischen Angriffsvektoren liegt. Die zugrunde liegenden Konzepte lassen sich auf nahezu alle Formen von Passwortdaten übertragen.

>[!abstract] Grundlagen: Hash-Werte und Hash-Kodierung
>Geht es um die Speicherung von Passwörtern, so werden diese – bei sicher konzipierten Systemen nicht im Klartext abgelegt. Stattdessen wird das Passwort durch ein Hashverfahren in einen Wert fester Länge umgewandelt. Bei einer Authentifizierung wird die aktuelle Passworteingabe mit demselben Verfahren gehasht, und die resultierenden Werte werden miteinander verglichen. Auf diese Weise lässt sich im Fall von Systemfehlern oder Datenlecks zumindest die Preisgabe der ursprünglichen Passwörter verhindern.
>
>Dieser Festwert wird als Hash-Wert (kurz: Hash) bezeichnet und durch einen sogenannten Hash Algorithmus erzeugt. Ein solcher Algorithmus bildet Eingaben beliebiger Länge auf eine Ausgabemenge fester Länge ab. Für den Einsatz in sicherheitsrelevanten Kontexten ist entscheidend, dass diese Einwegtransformation möglichst kollisionsresistent ist – also dass verschiedene Eingaben nur äußerst selten denselben Hash erzeugen und dass die Berechnung eine konsistente und ausreichend lange Laufzeit aufweist, um Angriffe zu erschweren.
>
>![[Pasted image 20251031174036.png]]
>
>**Base64-Kodierung:**
>Neben der Darstellung eines Hash-Werts in hexadezimaler Form ist es ebenso gängig, diesen in einer Base64-Kodierung oder in verwandten Varianten (z. B. Radix-64) darzustellen. **Base64 nutzt hierzu 64 Zeichen** (A-Z, a-z, 0-9, +, /) und kodiert jeweils **6 Bit pro Zeichen**, also 3 Byte Eingangsdaten zu 4 Zeichen Ausgangsdaten. Reicht der letzte Datenblock nicht aus, wird dieser mit dem Zeichen „=“ aufgefüllt. So kann der hexadezimale MD5-Hash `5f4dcc3b5aa765d61d8327deb882cf99` auch im Base64-Format als `X03MO1qnZdYdgyfeuILPmQ==` dargestellt werden.
>
>**Präffix/Suffix-Kennungen:**
>Werden in einem System verschiedene Hash-Algorithmen eingesetzt, müssen diese eindeutig identifizierbar sein. Dazu existieren Präfix- oder Suffix-Kennungen, die den jeweiligen Algorithmus und teilweise auch spezifische Parameter wie Rundenanzahl oder Salt Länge kodieren. Weit verbreitet ist hierfür das Modular Crypt Format (MCF), das eine einheitliche Kennzeichnung von Passwort-Hashes ermöglicht. Darauf aufbauend wurde 2016 das stärker standardisierte PHC-String-Format (Password Hashing Competition) eingeführt, das modernere Verfahren und Parameterstrukturen unterstützt. In sind beispielhaft zwei kodierte Hash-Werte in diesen Formaten dargestellt.
>
>![[Pasted image 20251031174917.png]]
>
>**Salt:**
>In den meisten Fällen wird für Passwortdaten eine zusätzliche Zufallskomponente in das vom Nutzer gewählte Passwort integriert (z. B. einfach angehängt oder vorangestellt). Diese Zufallssequenz wird Salt1 genannt. Der Salt wird für jeden Passworteintrag neu erzeugt und bei der Passwortprüfung erneut benötigt. Daher wird er im formatierten Hash zusammen mit weiteren Metadaten gespeichert (vgl. Abbildung 1). Diese Vorgehensweise bietet nicht nur Vorteile im Hinblick auf Passwortsicherheit, sondern erschwert auch verschiedene Angriffsarten erheblich oder macht sie ganz unwirksam.
>
>**Pepper:**
>Für Anwendungen mit erhöhtem Schutzbedarf kann zusätzlich ein Pepper – auch Secret Salt oder Secret Key genannt – eingesetzt werden. Pepper wird ebenfalls vor der Hash-Berechnung mit dem Passwort kombiniert, jedoch nicht gemeinsam mit dem Hash-Wert gespeichert. Stattdessen wird dieser geheime Schlüssel in einer separaten, besonders geschützten Persistenzschicht des Servers abgelegt. So bleiben selbst bei einem Datenbankleck keine direkt nutzbaren Informationen über die Passwortableitung zurück.
>
>Diese Erweiterungen und Anreicherungen der Passwortdaten werden vor allem bei kryptografischen Hashfunktionen verwendet, um deren Sicherheit zu erhöhen. Dadurch führen selbst identische Passwörter zu unterschiedlichen Hash-Werten, wodurch Wiederholungen und Muster vermieden werden. Neben den in diesem Praktikum relevanten kryptografischen Hashverfahren existieren zahlreiche weitere Anwendungsgebiete für Hashes, die teils andere Anforderungen an die Transformation stellen. Die in Abbildung 1 dargestellten Algorithmen gehören bereits zu einer speziellen Untergruppe, den sogenannten Schlüsselableitungsfunktionen (Key Derivation Functions, KDF). Tabelle 2 zeigt beispielhaft verschiedene Einsatzfelder solcher Funktionen und ihre jeweiligen Anforderungen.
>
>![[Pasted image 20251031175817.png]]

>[!info] Grundlagen: Passwortangriffe
>Der Angriff auf ein Passwort folgt grundsätzlich immer demselben Schema: Ein Eingangswort wird mit der erwarteten Hash-Transformation verarbeitet und der resultierende Wert mit dem gespeicherten Passwort-Hash verglichen. Stimmen beide Werte überein, gilt das Eingangswort als gültiges Passwort. Je nach Hash-Algorithmus können dabei theoretisch mehrere Eingaben denselben Hash erzeugen (Stichwort: Kollisionen).
>
>Ist ein Passwort ohne zusätzlichen Salt gespeichert, ergibt sich daraus ein sehr einfaches Angriffsszenario. Man nimmt ein Wörterbuch oder eine Passwortliste, berechnet für alle Einträge den entsprechen den Hash und speichert diese Werte sortiert in einer sogenannten Hash-Tabelle bzw. Rainbow-Table. Anschließend wird geprüft, ob der Ziel-Hash in der Tabelle vorkommt – ist das der Fall, kennt man das zugehörige Passwort. Solche Tabellen lassen sich in großem Umfang vorbereiten und mehrfach wiederverwenden.
>
>Wird ein Passwort hingegen mit einem individuellen Salt gespeichert, ist dieses Vorgehen nicht mehr praktikabel. Als Alternative kann das Wörterbuch bzw. die Passwortliste für jeden einzelnen Salt- Wert neu verarbeitet werden, um einen Wörterbuchangriff gezielt auf ein bestimmtes Passwort auszuführen. Da jedes Passwort seinen eigenen Salt besitzt, ist dieses Vorgehen deutlich aufwändiger und langsamer. Existiert zusätzlich ein geheimer Pepper (Secret Salt), der dem Angreifer nicht bekannt ist, scheitert auch dieser Ansatz.
> 
>Der Erfolg eines Passwortangriffs hängt daher maßgeblich von der Qualität des verwendeten Wörter- buchs oder der Passwortliste ab. Mittels gezieltem Profiling – also der Sammlung von Informationen über Personen, Organisationen oder Gruppen – können spezifische Passwortlisten erstellt werden. Solche Listen werden häufig durch Rekombination, Substitution und Transformation erweitert, etwa durch Varianten in Leet-Speak oder typische Schreibmuster bestimmter Nutzergruppen
>
>**John the Ripper:**
>Das Programm John the Ripper dient in diesem Zusammenhang als Beispiel für ein Passwort-Cracking-Tool und dessen Arbeitsweise. In der Standardkonfiguration arbeitet das Tool in drei Phasen:
>- Phase 1 – Single Crack and Mangling: Das Programm versucht zunächst, Passwörter aus vorhandenen Zusatzinformationen oder bekannten Mustern zu erraten (sehr schnell).
>
>- Phase 2 – Wörterbuchangriff: Es werden alle Einträge aus einer Passwortliste getestet. Dauer und Aufwand hängen von der Größe des Wörterbuchs und der verwendeten Hash-Funktion ab.
>
>- Phase 3 – Bruteforce: Schließlich werden alle möglichen Zeichenkombinationen systematisch durchprobiert, bis ein Treffer erzielt wird. Dieser Prozess kann je nach Passwortkomplexität astronomisch lange dauern.
>
>John the Ripper erwartet die Eingabedatei in einem der folgenden Formate (ein Eintrag pro Zeile):
>`Hash`
>`Nutzername:Hash`
>`Nutzername:Hash:Zusatzinformationen`
>(je mehr informationen, desto besser - siehe Phase 1.)
>
>**hashcat**
>John the Ripper nutzt standardmäßig die Rechenleistung der CPU, kann aber – je nach Version und Konfiguration – auch GPU-Ressourcen einbeziehen. Für die in den bereitgestellten virtuellen Maschinen durchzuführenden Experimente ist das Tool daher sehr gut geeignet. Für großflächigere Passwortangriffe oder Wiederherstellungsprojekte empfiehlt sich hingegen das Programm hashcat, das für GPU-Architekturen optimiert ist und deutlich besser skaliert. Beide Tools haben ihre jeweiligen Stärken: John the Ripper ist flexibel, skriptfreundlich und ideal für forensische Einzelanalysen, während hashcat durch massive Parallelisierung eine hohe Rechenleistung bei umfangreichen Hash-Mengen ermöglicht.

