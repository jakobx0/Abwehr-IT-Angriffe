> [!info]
 SiLK als Tool für NetFlow Analysen. Flow beschreibt eine Folge von zusammenhängender und gerichteter Pakete, die eine unidirektionale Kommunikation zwischen zwei Endpunkten abbildet. Die Gruppierung erfolgt auf Basis gemeinsamer Attribute wie Quell- und Zieladresse, verwendete Ports und das transportierende Protokoll. Zusätzlich spielt die zeitliche Nähe der Pakete eine Rolle. Ein Flow kann beispielsweise automatisch enden, wenn für eine bestimmte Dauer keine weiteren Pakete beobachtet werden oder wenn ein neuer Flow mit abweichenden Parametern beginnt. Die genaue Definition eines Flows ist nicht vollständig standardisiert. Unterschiede zwischen gängigen Formaten wie NetFlow, IPFIX und den jeweiligen Tool Implementierungen sind üblich. Daher sollte man Flow-Begriffe stets im Kontext des eingesetzten Werkzeugs betrachten.
 >
 >Neben den eigentlichen Datenfeldern werden weitere Flow-Metadaten in Form von NetFlow Packet Headern erfasst. Diese Header enthalten allgemeine Informationen über die jeweilige NetFlow-Übertragung, etwa die verwendete Protokollversion oder die fortlaufende Flow-Sequenznummer. Sie sind wichtig, um die Konsistenz der Datenströme zu prüfen und die exportierten Flows korrekt einordnen zu können.
 >
 >![[Pasted image 20260111171626.png]]
 >

#### Beispiel: Client-Server Kommunikation 
>[!abstract]
>Client-Server-Kommunikation mit einem Webserver dargestellt und wie diese Interaktion durch verschiedene Flows modelliert werden kann.
>
>![[Pasted image 20260111171807.png]]
>

#### SiLK - Befehle
>[!info] Befehle
>
>![[Pasted image 20260111172243.png]]

Wie viele Bytes wurden von der Quell-IP 10.1.60.73 über den Quell-Port 5269 gesendet?
Verwenden Sie dabei die Möglichkeit von rwuniq, sich statt der Anzahl der Records direkt
die Gesamtsumme der Bytes (--bytes) ausgeben zu lassen.

Welche standardisierten Ports (0-1023) werden als Ziele von Verbindungen verwendet und
wie oft? Bestimmen Sie für diese den dahinter laufenden Dienst (gern mit Unterstützung
des Internets). Hinweis: Für ICMP werden Typ und Code für ein einfacheres Mapping auch
im Feld des Zielports nach der Formel „typ * 256 + code“ eingetragen – die Portnummer ist
demnach für ICMP nicht valide.

55.230.1.1 echo 255.230.1.1 > set1.txt
22.11.1.128/30 echo 22.11.1.128/30 >> set1.txt
111.2.3-4.1-2 

### SilK lesen und interpretieren

>[!question]
>```bash
>rwfilter DATEI --protocol=6,17 --fail=stdout | rwuniq --fields=1,2,5,25
>```
>- Zeigt die Felder sip, dip, protocol, icmptypecode an die weder IPv6 noch UDP Verbindungen sind.
>
>```bash
>rwset DATEI --sip-file=current.sipset
>```
>- Erzeugt eine Liste der Quell-IPs
>
>```bash
>rwsettool --difference current.sipset whitelist.sipset > difference.sipset
>```
>- bildet ein sipset des aktuellen sipsets welches alle IPs enthält die nicht in der whitelist enthalten sind.  
>
>```bash
>rwfilter DATEI --sipset=difference.sipset --pass=stdout | rwfilter --input-pipe=stdin --dport=53 --fail=stdout | 
>rwuniq  -fields=1,2,4
>```
>- Zeigt nur unbekannt IPs, die auf Ports anders als vom DNS Verbindungen hatten
>
>Assoziieren Sie die IP-Adressen mit Clients bzw. Servern und interpretieren Sie, was hier passiert:
>
>![[Pasted image 20260112105122.png]]
>
>- 1. Anfrage von 192.168.1.42 an DNS Server über port 53 (DNS Auflösung)
>- 2. Antwort von DNS-Server 
>- 3. Verbindungs aufbau an FTP-Server (Übermittlung von Daten -> 18 Pakete)
>- 4. Empfangen von Daten (FTP-Server) -> (Übermittlung von 16 Paketen)
>
>![[Pasted image 20260112105642.png]]
>
>
