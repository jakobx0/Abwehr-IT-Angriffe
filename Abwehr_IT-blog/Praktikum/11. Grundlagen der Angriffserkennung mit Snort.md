>[!abstract] Grundlagen:
>
>Ein Intrusion Detection System (IDS) dient der Überwachung von Netzwerk- oder Systemaktivitäten mit dem Ziel, potenziell unerwünschten Datenverkehr zu erkennen. In der Praxis werden detektierte Ereignisse in der Regel protokolliert und an System- oder Netzwerkadministratoren gemeldet, etwa in Form von Logeinträgen oder Alarmen. Erfolgt über die reine Erkennung hinaus auch eine aktive Reaktion auf entsprechenden Datenverkehr, beispielsweise durch das Blockieren von Verbindungen oder das Verwerfen von Paketen, spricht man von einem Intrusion Prevention System (IPS).
>
>Beide Systemklassen lassen sich zusätzlich danach unterscheiden, ob sie den Datenverkehr eines gesamten Netzwerks analysieren oder auf die Überwachung einzelner Systeme beschränkt sind. Im ersten Fall spricht man von netzwerkbasierten Systemen (Network-based IDS/IPS, NIDS bzw. NIPS), im zweiten Fall von hostbasierten Systemen (Host-based IDS/IPS, HIDS bzw. HIPS).
>
>Snort ist in der Lage, Netzwerkverkehr in Echtzeit zu analysieren und dabei die Inhalte von Netzwerkprotokollen mit bekannten Mustern abzugleichen. Das primär signaturbasierte System arbeitet dabei in vereinfachter Form wie in dargestellt und lässt sich durch Plugins modular erweitern.
>
>![[Pasted image 20260129141054.png]]
>
>Der zu analysierende Datenverkehr wird zunächst paketweise durch sogenannte Codec-Plugins validiert. In diesem Schritt werden grundlegende Netzwerkmerkmale wie Quell- und Zieladressen sowie Ports überprüft, die Protokollhierarchie verifiziert und der Datenverkehr auf grobe Anomalien hin untersucht. Anschließend analysieren Inspector-Plugins die dekodierten Pakete detaillierter im Hinblick auf ihren ursprünglichen semantischen Inhalt. Dabei werden fragmentierte Pakete bei Bedarf korrekt reassembliert, um die originale Protokolldateneinheit (Protocol Data Unit, PDU) wiederherzustellen. Die PDUs werden anschließend normalisiert und analysiert, was insbesondere der Erkennung und Abwehr von Umgehungsversuchen dient. Nach dieser Präprozessierung gelangen die aufbereiteten Daten in den eigentlichen Erkennungsprozess des IDS.
>
>Dieser Erkennungsprozess lässt sich vereinfacht in zwei Phasen gliedern. Zunächst werden die definierten Regeln zu einer effizienten parallelen Suche zusammengefasst, getrennt nach Protokoll, Dienst und Port. Diese Regelgruppen werden durch Mustersuch-Plugins (Multipattern Search Engine, MPSE) an- hand ihrer entscheidenden Inhaltsmuster (fast pattern content) aufbereitet und mit den Paketinhalten abgeglichen. Bei einem Treffer wird die vollständige Regel-Signatur anschließend sequenziell ausgewertet. Wird eine Regel vollständig erfüllt, reagiert das System im letzten Schritt abhängig von der konfigurierten Aktion. Die Definition und Pflege der Regeln ist entscheidend für den erfolgreichen Einsatz eines IDS bzw. IPS und erfolgt entweder über eine spezialisierte Textsyntax oder, bei weitergehenden Anforderungen, über die Implementierung eigenen Quellcodes.

### Snort Rules
>[!info]
>
>![[Pasted image 20260129142700.png]]
>
>Eine Snort-Regel besteht grundsätzlich aus einem Kopfteil (rule header) und einem Regelkörper (rulebody). Im Header wird die auszuführende Aktion (action) definiert, die ausgelöst wird, sobald die Regel zutrifft. Darüber hinaus legt der Header das zu überwachende Protokoll der OSI-Schicht 3 oder 4 fest (z. B. ICMP, IP, TCP, UDP) oder spezifiziert einen Dienst höherer OSI-Schichten (z. B. FTP, HTTP, IMAP), der analysiert werden soll. Der Body enthält eine Sammlung vordefinierter Optionen (rule options), die die eigentliche Erkennung des Datenverkehrs übernehmen und darüber hinaus weiterführende Informationen bereitstellen.
>
>Die gewählte Aktion hängt direkt vom Modus ab, in dem Snort gestartet wird. Einige Aktionen stehenausschließlich im IPS-Modus zur Verfügung und erfordern eine entsprechende Konfiguration. Eine Übersicht der aktuell unterstützten Aktionen sowie ihrer Auswirkungen finden Sie in Tabelle 1. Für maximale Flexibilität enthalten die offiziell bereitgestellten Regeln häufig nur Warnmeldungen in Form von Alerts, die bei Bedarf weiterverarbeitet oder an externe Systeme weitergeleitet werden können
>
>![[Pasted image 20260129143144.png]]
>
>Die weiteren Angaben im Kopfteil einer Regel dienen der Vorfilterung der zu untersuchenden Netzwerkpakete sowie der Gruppierung ähnlicher Regeln, um eine doppelte Analyse desselben Datenver- kehrs zu vermeiden. Das Schlüsselwort „any“ kann dabei als Platzhalter für beliebige Quell- und Ziel-adressen sowie Portangaben verwendet werden. Als Adressen sind einzelne IP-Adressen, IP-Bereiche in CIDR-Notation oder Kombinationen dieser Angaben zulässig. Ports lassen sich ebenfalls einzeln, als Bereich oder in Kombination definieren. Fehlen im Kopfteil weitere Angaben neben Aktion und Protokoll, werden die nicht spezifizierten Werte automatisch als „any“ interpretiert. Die Richtung des Datenverkehrs wird durch „->“ für unidirektional oder „<>“ für bidirektional festgelegt.
>
>![[Pasted image 20260129143559.png]]
>
>Der **Regelkörper(rule body)** besteht ausschließlich aus Optionen (IPS rule options). Diese bilden die zentralen Bausteine für die Erkennung von Netzwerkverkehr und lassen sich bei Bedarf durch zu- sätzliche Plugins erweitern. Es gibt neben allgemeinen Optionen, die universell einsetzbar sind, auch sehr spezifische Optionen, die nur für bestimmte Protokolle oder Dienste relevant sind. Eine Auswahl der häufig verwendeten Optionen ist in Tabelle 2 dargestellt. Optionen können als logische Marker auftreten, einen oder mehrere Werte erhalten oder zusätzliche Parameter mit spezifischer Syntax erfordern.
>
>![[Pasted image 20260129143808.png]]
>
>Neben allgemeinen Optionen, wie msg zur Ausgabe einer Meldung beim Auslösen einer Regel oder classtype zur Klassifizierung der Regel, existieren zahlreiche spezifische Optionen, die einzelne Pro- tokollfelder prüfen, um die Auslösung eines Ereignisses gezielt einzuschränken. Zur Erkennung von Inhalten innerhalb des Protokoll-Payloads (abhängig vom im Kopfteil der Regel spezifizierten Protokoll) können verschiedene Optionen genutzt werden, die auf Textinhalte prüfen (einfache Textsuche oder reguläre Ausdrücke) oder auf hexadezimale Werte (eingeschlossen in senkrechten Strichen). Der Suchraum lässt sich durch Positionsmarker (cursor, buffer) oder über Optionsparameter wie offset und depth begrenzen. Darüber hinaus sind Berechnungen oder Vergleiche von Bytewerten innerhalb der Nutzdaten möglich. Werden mehrere Inhaltsoptionen in einer Regel verwendet, sollte mit dem Parameter „fast_pattern“ ein primäres Suchmuster festgelegt werden, das zuerst von den Mustersuch-Plugins überprüft wird. Fehlt dieser Parameter, wählt Snort automatisch das längste Suchmuster als primäres Muster aus.
>
>Alle Regeln werden nach einem einheitlichen Schema nummeriert und verwaltet. Jede Regel erhält eine eindeutige Signatur-ID (sid) sowie eine Revisionsnummer (rev). Bei einer Aktualisierung der Regel bleibt die SID unverändert, während die Revisionsnummer inkrementiert wird. Zusätzlich besitzt jede Regel eine Generator-ID (gid), die der groben Klassifizierung des Regeltyps dient: Text-Regeln erhalten standardmäßig die GID 1, dynamische Regeln die GID 3. Alle Regeln müssen über eine SID verfügen und werden nach dem Schema „**gid:sid:rev**“ gruppiert.
>
>Eine einfache **Beispielregel** zur Erkennung eines „Pings“ (ICMP-Typ 8) von einem Windows-Betriebssystem außerhalb des lokalen Netzwerks könnte beispielsweise wie folgt aussehen
>```bash
>alert icmp $EXTERNAL_NET any -> $HOME_NET any
( msg: "Ping (Win)"; itype: 8; content: "abcdefghijklmnop", depth 16; sid: 38; rev: 3; )
>```


### Beispiel Regeln
>[!question] 
>```bash
>#CMP-Pakete mit aktiven Echo-Anfragen (Typ 8, „Ping“): | hinzugefügter classtype
>alert icmp (msg: "ICMP-Ping"; itype: 8;classtype: icmp-event; sid: 1; rev: 2;)
>
#Überwachen Sie aus- und eingehenden FTP-Datenverkehr im Heimnetz auf Port 21:
alert tcp $HOME_NET any -> any 21 (msg: "Outgoing FTP"; sid: 10;)
alert tcp any 21 -> $HOME_NET any (msg: "Incomming FTP"; sid: 11;)
>
#TCP-Pakete, die die Schlagworte „tux“ oder „chemnitz“ enthalten:
alert tcp (msg: "Schlagwort: tux"; content: "tux"; sid: 20;)
alert tcp (msg: "Schlagwort: chemnitz"; content: "chemnitz"; sid: 21;)
>
#HTTP-Datenverkehr, der das Schlagwort „tux“ enthält:
alert http (msg: "HTTP: tux"; content: "tux"; sid: 30;)
>```
>
>```bash
>#Überprüfen der Regeldatei mit der Snort-Konfiguration
snort -c configuration -R /home/hsmw/data/snort/local.rules --warn-rules -T
>```
>
>```bash
#Snort kann grundsätzlich in drei Modi betrieben werden: als einfacher Paket-Sniffer, als IDS oder als IPS. Der gewählte Modus hängt von der Konfiguration, den geladenen Regeln und den Aufrufparametern ab. Starten Sie Snort im IDS-Modus auf Ihrem aktuellen Netzwerkinterface, um den Datenverkehr anhand der erstellten Regeln zu überwachen. Hinweis: Um mit einem Netzwerkinterface arbeiten zu können, muss Snort mit erhöhten Rechten gestartet werden.
>
>snort -c configuration -R rules -i interface -k none -s 65535 -A alert_fast -e -U -y
>
>-e: #Fügt zusätzliche Informationen aus der OSI-Schicht 2 hinzu (MAC-Adressen, etc.)
>-U: #Verwendet die unabhängige UTC-Zeit anstelle der Lokalzeit
>-y: #Ergänzt die Log-Einträge um die Jahreszahl
>```
>
>>[!success] Ergebniss von Ping (alert_fast)
>>![[Pasted image 20260129164949.png]]
>
>>[!success] Ergebnis von Ping -e -U -y (alert_full)
>>![[Pasted image 20260129163718.png]]
>
>```bash
> #In manchen Szenarien kann es sinnvoll sein, eine Regel erst auszulösen, wenn ein bestimmtes Ereignis mehrfach auftritt. Fügen Sie daher eine neue Regel zur Erkennung von „Pings“ hinzu, die erst aktiviert wird, sobald innerhalb von 4 Sekunden mindestens 3 Pakete von erselben Quelle erfasst wurden (detection_filter). Seit Snort 3 können Regeln mehrere Zei- len einschließlich Leerzeilen enthalten, was die Übersichtlichkeit und Lesbarkeit komplexer Regeln deutlich verbessert:
> 
>     alert icmp(
>         msg: "ICMP x3";
>         itype: 8;
>         classtype: icmp-event;
>         detection_filter: track by_src, count 3, seconds 4;
>         sid: 2;
>         rev: 1;)
>```
>
>```bash
>#In den FTP-Regeln wurde bereits die Richtung des Datenstroms im Header festgelegt und auf spezifische Ports verwiesen. Neben konkreten Adress- und Portangaben können Sie in den Regeln auch vorbereitete Variablen oder feste Werte verwenden:
>
>alert tcp $HOME_NET any -> any $FTP_PORTS (msg: "Outgoing FTP"; sid: 10; rev: 2;)
>
>alert tcp $EXTERNAL_NET [21,2100,3535] -> $HOME_NET any (msg: "Incomming FTP"; sid: 11; rev: 2;)
>```
>
>```bash
>#Einfache Inhaltsprüfungen nach Zeichenketten lassen sich ebenfalls weiter verfeinern. So können Schlagworte z.B. unabhängig von Groß- und Kleinschreibung gesucht werden:
>
>alert tcp (msg: "Schlagwort: chemnitz"; content: "chemnitz", nocase; sid: 21; rev: 2;)
>```
>
>```bash
>#Snort unified2 Log-Format Parameter: (-m 0x5B)
>
> snort -c configuration -R rules -i interface -k none -s 65535 -A u2 -m 0x5B -e -U -y
>```
>
>```bash
>#Ein Alert auf alle udp pakete aus dem eigenen Netz welche eine DNS auflösung über Port 53 mit dem namen facebook groß ode klein geschrieben anfragen. 
>
>alert udp $HOME_NET any -> any 53
(msg: "[DNS] Facebook"; content: "facebook", nocase; sid: 1234567; rev: 4;)
>```
>
>```bash
>#Alert auf tcp Pakete welche nicht von einem S7_Server kommen und sich mit einem S7 Client über Port 102 Verbinden wollen. Sucht über content im Payload nach 0x72 -> s7comm-plus Paketen an der 7 stelle im Payload und guckt sich nur das eine Byte an.
>
>alert tcp !$S7_SERVER any -> $S7_CLIENT 102
(msg: "SCADA"; content: "|72|", offset 7, depth 1; sid: 100; rev: 2;)
>```
>
>```bash
>#SCADA Regel prüft auf "Request" (0x31) und "SetMultiVariables" (0x0542) eines s7comm-plus-Paket
>
>alert tcp any any -> any 102 (
 >   msg: "SCADA: Pumpensteuerung";
 >   content: "|72|"; offset: 7; depth: 1; fast_pattern;
>    content: "|31|"; offset: 44; depth: 1;
>    content: "|05 42|"; offset: 47; depth: 2;
>    sid: 102;
 >   rev: 1;
>)
>```
>
>```bash
>#Netzwerkausschnitte analysieren
>snort -c configuration -R rules -k none -s 65535 -A alert_talos -q --pcap-dir /home/hsmw/data/scada
>
>-A #alert_talos: Log-Format aller Ereignisse ohne Paketdaten (nur am Ende ichtbar)
 -q: #Deaktiviert die Standardausgaben beim Initialisieren und die Statistiken am Ende (quiet)
 --pcap-dir directory: #Verzeichnis, aus dem kompatible Mitschnitte gelesen werden
>```
>
>![[Pasted image 20260130131825.png]]



